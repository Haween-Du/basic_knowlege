<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const bt = {
        val: 1,
        left: {
          val: 2,
          left: {
            val: 4,
            left: null,
            right: null,
          },
          right: {
            val: 5,
            left: null,
            right: null,
          },
        },
        right: {
          val: 3,
          left: {
            val: 6,
            left: null,
            right: null,
          },
          right: {
            val: 7,
            left: null,
            right: null,
          },
        },
      };
      const preorder = (root) => {
        if (!root) return;
        console.log(root.val);
        preorder(root.left);
        preorder(root.right);
      };
      /*
        三部曲
        1.确认递归函数的参数和返回值
        2.确定终止条件
        3.确定单层递归的逻辑
      */
      // preorder(bt);  非递归版先序遍历
      /*
      三部曲
      1.没有返回值   参数是要遍历的二叉树
      2.前序遍历终止条件  左边到达根返回   然后又边到达根结束
      3.
      */
      const preorder2 = (root) => {
        if (!root) return;
        const stack = [root];
        // 4.遍历去不断执行
        while (stack.length) {
          // 1.先访问根节点的值 弹出来就可以
          const n = stack.pop();
          console.log(n.val);
          // 2.要先把右子树推入到栈中 因为栈是后进先出
          if (n.right) stack.push(n.right);
          // 3.把左子树推入到栈中
          if (n.left) stack.push(n.left);
        }
      };
      preorder2(bt);
    </script>
  </body>
</html>
