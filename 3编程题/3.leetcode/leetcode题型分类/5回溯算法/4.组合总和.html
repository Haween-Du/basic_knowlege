<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
              39  https://leetcode.cn/problems/combination-sum/
               给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

      candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。

      对于给定的输入，保证和为 target 的不同组合数少于 150 个。



      示例 1：

      输入：candidates = [2,3,6,7], target = 7
      输出：[[2,2,3],[7]]
      解释：
      2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
      7 也是一个候选， 7 = 7 。
      仅有这两种组合。

      回溯三部曲
     1.递归函数参数返回值
     2.确定终止条件
     3. 确定单层递归逻辑
              */
      //  树的深度没有确定  元素可以重复使用
      let candidates = [2, 3, 6, 7],
        target = 7;
      function fn(candidates, target) {
        const res = [],
          path = [];
        let sum = 0;
        candidates.sort((a, b) => a - b); // 排序
        backtracking(0);
        return res;
        function backtracking(startIndex) {
          if (sum === target) {
            res.push(Array.from(path));
            return;
          }
          //   为什么不可以等于
          for (let i = startIndex; i < candidates.length; i++) {
            const n = candidates[i];
            // 和大于target 和大于target 可以跳出循环了
            if (n > target - sum) break;
            path.push(n);
            sum += n;
            // 因为元素可以重复使用  所以传入i 不用++
            backtracking(i);
            path.pop();
            sum -= n;
          }
        }
      }

      console.log(fn(candidates, target));
    </script>
  </body>
</html>
